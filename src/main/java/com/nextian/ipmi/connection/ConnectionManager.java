/*
 * Copyright (c) Nextian. All rights reserved.
 *
 * This software is furnished under a license. Use, duplication,
 * disclosure and all other uses are restricted to the rights
 * specified in the written license agreement.
 *
 */
package com.nextian.ipmi.connection;

import com.nextian.ipmi.coding.commands.PrivilegeLevel;
import com.nextian.ipmi.coding.commands.session.GetChannelAuthenticationCapabilitiesResponseData;
import com.nextian.ipmi.coding.security.CipherSuite;
import com.nextian.ipmi.common.Defaults;
import com.nextian.ipmi.transport.Messenger;
import com.nextian.ipmi.transport.UdpListener;
import com.nextian.ipmi.transport.UdpMessenger;

import javax.crypto.NoSuchPaddingException;
import java.io.IOException;
import java.net.InetAddress;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.LinkedBlockingDeque;

/**
 * Manages multiple {@link Connection}s
 */
public class ConnectionManager {
    private static final int SESSIONLESS_FREE_TAGS_NUMBER = 60;
    private static Integer sessionId = 100;
    private static BlockingDeque<Integer> freeTags;
    private Messenger messenger;
    private List<Connection> connections;

    /**
     * Initialize list of free sessionless tags
     */
    private static synchronized BlockingDeque<Integer> getFreeTags() {
        if (freeTags == null) {
            freeTags = new LinkedBlockingDeque<Integer>();
            for (int i = 0; i < SESSIONLESS_FREE_TAGS_NUMBER; i++) {
                freeTags.add(i);
            }
        };
        return freeTags;
    }

    /**
     * Initiates the connection manager. Wildcard IP address will be used.
     *
     * @param port the port at which {@link UdpListener} will work
     * @throws IOException when properties file was not found
     */
    public ConnectionManager(int port) throws IOException {
        messenger = new UdpMessenger(port);
        initialize();
    }

    /**
     * Initiates the connection manager.
     *
     * @param port    the port at which {@link UdpListener} will work
     * @param address the IP interface {@link UdpListener} will bind to
     * @throws IOException when UDP socket cannot be created
     */
    public ConnectionManager(int port, InetAddress address) throws IOException {
        messenger = new UdpMessenger(port, address);
        initialize();
    }

    /**
     * Initiates the connection manager.
     *
     * @param messenger {@link Messenger} to be used in communication
     */
    public ConnectionManager(Messenger messenger) {
        this.messenger = messenger;
        initialize();
    }

    /**
     * The session ID generated by the {@link ConnectionManager}. Auto-incremented.
     */
    public static synchronized int generateSessionId() {
        sessionId %= (Integer.MAX_VALUE / 4);
        return sessionId++;
    }

    /**
     * The tag for messages sent outside the session generated by the {@link ConnectionManager}. Auto-incremented.
     */
    public static int generateSessionlessTag() throws InterruptedException {
        return getFreeTags().take();
    }

    /**
     * Frees the sessionless tag for further use
     *
     * @param tag tag to free
     */
    public static void freeTag(int tag) throws InterruptedException {
        if (tag >= 0 && tag <= SESSIONLESS_FREE_TAGS_NUMBER) {
            getFreeTags().put(tag);
        }
    }

    /**
     * Initialize object (like constructor but can be reused)
     */
    private void initialize() {
        connections = new ArrayList<Connection>();
    }

    /**
     * Closes all open connections and disconnects {@link UdpListener}.
     */
    public void close() {
        synchronized (connections) {
            for (Connection connection : connections) {
                if (connection != null && connection.isActive()) {
                    connection.disconnect();
                }
            }
        }
        messenger.closeConnection();
    }

    /**
     * Returns {@link Connection} identified by index.
     *
     * @param index index of the connection to return
     */
    public Connection getConnection(int index) {
        return connections.get(index);
    }

    /**
     * Closes the connection with the given index.
     */
    public void closeConnection(int index) {
        connections.get(index).disconnect();
    }

    /**
     * Returns first {@link Connection} associated with the address.
     *
     * @param address {@link InetAddress} of the remote host to get connection with.
     * @return First {@link Connection} to the address or null if none found
     */
    public Connection getConnection(InetAddress address) {
        synchronized (connections) {
            for (Connection connection : connections) {
                if (connection != null && connection.isActive() && connection.getRemoteMachineAddress() == address) {
                    return connection;
                }
            }
        }
        return null;
    }

    /**
     * Creates and initiates {@link Connection} to the remote host.
     *
     * @param address           {@link InetAddress} of the remote host
     * @param keepalivePeriod   frequency of the no-op commands that will be sent to keep up the session
     * @param timeout           requests timeout in ms
     * @param cleaningFrequency delay in ms between message queue cleaning action (responsible for timeout discovery)
     * @return index of the connection
     */
    public int createConnection(InetAddress address, int keepalivePeriod, int timeout, int cleaningFrequency) {
        Connection connection = new Connection(messenger, 0, timeout, cleaningFrequency);
        connection.connect(address, keepalivePeriod);

        synchronized (connections) {
            connections.add(connection);
            return connections.size() - 1;
        }
    }

    /**
     * Creates and initiates {@link Connection} to the remote host.
     *
     * @param address           {@link InetAddress} of the remote host
     * @param skipCiphers       determines if the getAvailableCipherSuites and getChannelAuthenticationCapabilities phases
     *                          should be skipped
     * @param keepalivePeriod   frequency of the no-op commands that will be sent to keep up the session
     * @param timeout           requests timeout in ms
     * @param cleaningFrequency delay in ms between message queue cleaning action (responsible for timeout discovery)
     * @return index of the connection
     */
    public int createConnection(InetAddress address, boolean skipCiphers, int keepalivePeriod, int timeout, int cleaningFrequency) {
        Connection connection = new Connection(messenger, 0, timeout, cleaningFrequency);
        connection.connect(address, keepalivePeriod, skipCiphers);

        synchronized (connections) {
            connections.add(connection);
            return connections.size() - 1;
        }
    }

    /**
     * Creates and initiates {@link Connection} to the remote host with the default ping frequency.
     *
     * @param address {@link InetAddress} of the remote host
     * @return index of the connection
     */
    public int createConnection(InetAddress address) {

        synchronized (connections) {
            Connection connection = new Connection(messenger, connections.size(), Defaults.TIMEOUT, Defaults.CLEANING_FREQUENCY);
            connection.connect(address, Defaults.KEEPALIVE_DELAY);
            connections.add(connection);
            return connections.size() - 1;
        }
    }

    /**
     * Creates and initiates {@link Connection} to the remote host with the default ping frequency.
     *
     * @param address     {@link InetAddress} of the remote host
     * @param skipCiphers determines if the getAvailableCipherSuites and getChannelAuthenticationCapabilities phases should be skipped
     * @return index of the connection
     */
    public int createConnection(InetAddress address, boolean skipCiphers) {
        synchronized (connections) {
            Connection connection = new Connection(messenger, connections.size(), Defaults.TIMEOUT, Defaults.CLEANING_FREQUENCY);
            connection.connect(address, Defaults.KEEPALIVE_DELAY, skipCiphers);
            connections.add(connection);
            return connections.size() - 1;
        }
    }

    /**
     * Gets from the managed system supported {@link CipherSuite}s. Should be performed only immediately
     * after {@link #createConnection}.
     *
     * @param connection index of the connection to get available Cipher Suites from
     * @return list of the {@link CipherSuite}s supported by the managed system.
     * @throws ConnectionException  when connection is in the state that does not allow to perform this operation.
     * @throws InterruptedException when thread is interrupted
     */
    public List<CipherSuite> getAvailableCipherSuites(int connection) throws ConnectionException, InterruptedException {
        int tag = generateSessionlessTag();
        List<CipherSuite> suites;
        try {
            suites = connections.get(connection).getAvailableCipherSuites(tag);
        } finally {
            freeTag(tag);
        }
        return suites;
    }

    /**
     * Queries the managed system for the details of the authentication process. Must be performed
     * after {@link #getAvailableCipherSuites(int)}.
     *
     * @param connection              index of the connection to get Channel Authentication Capabilities from
     * @param cipherSuite             {@link CipherSuite} requested for the session
     * @param requestedPrivilegeLevel {@link PrivilegeLevel} requested for the session
     * @return {@link GetChannelAuthenticationCapabilitiesResponseData}
     * @throws ConnectionException  when connection is in the state that does not allow to perform this operation.
     * @throws InterruptedException when thread is interrupted
     */
    public GetChannelAuthenticationCapabilitiesResponseData getChannelAuthenticationCapabilities(
            int connection, CipherSuite cipherSuite, PrivilegeLevel requestedPrivilegeLevel)
            throws ConnectionException, InterruptedException {
        int tag = generateSessionlessTag();
        GetChannelAuthenticationCapabilitiesResponseData responseData;
        try {
            responseData = connections.get(connection).getChannelAuthenticationCapabilities(tag, cipherSuite,
                    requestedPrivilegeLevel);
        } finally {
            freeTag(tag);
        }
        return responseData;
    }

    /**
     * Initiates the session with the managed system. Must be performed after
     * {@link #getChannelAuthenticationCapabilities(int, CipherSuite, PrivilegeLevel)}.
     *
     * @param connection     index of the connection that starts the session
     * @param cipherSuite    {@link CipherSuite} that will be used during the session
     * @param privilegeLevel requested {@link PrivilegeLevel} - most of the time it will be {@link PrivilegeLevel#User}
     * @param username       the username
     * @param password       the password matching the username
     * @param bmcKey         the key that should be provided if the two-key authentication is enabled, null otherwise.
     * @throws ConnectionException      when connection is in the state that does not allow to perform this operation.
     * @throws InterruptedException     when thread is interrupted
     * @throws NoSuchPaddingException   when cipher algorithm initialization fails
     * @throws NoSuchAlgorithmException when cipher algorithm initialization fails
     */
    public void startSession(int connection, CipherSuite cipherSuite, PrivilegeLevel privilegeLevel,
                             String username, String password, byte[] bmcKey)
            throws InterruptedException, ConnectionException, InvalidKeyException,
            NoSuchAlgorithmException, NoSuchPaddingException {
        int tag = generateSessionlessTag();
        try {
            connections.get(connection).startSession(tag, cipherSuite, privilegeLevel, username, password, bmcKey);
        } finally {
            freeTag(tag);
        }
    }

    /**
     * Registers the listener so it will receive notifications from connection.
     *
     * @param connection index of the {@link Connection} to listen to
     * @param listener   {@link ConnectionListener} to notify
     */
    public void registerListener(int connection, ConnectionListener listener) {
        connections.get(connection).registerListener(listener);
    }
}
